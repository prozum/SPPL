entrypoints Program ;

rules Program ::= [Func] ;
rules Func ::= Decl [Case] ;
rules Decl ::= "def" Id ":" Signature ;
rules Signature ::= Type "->" Signature | Type ;
rules Case ::= "|" [Pattern] "=" Expr ;
rules Pattern ::= Id | Literal | List_Split | Tuple_Pattern | List_Pattern ;
rules List_Split ::= "(" Pattern ":" Pattern ")" ;
rules Tuple_Pattern ::= "(" Pattern "," Pattern_ListNE ")" ;
rules List_Pattern ::= "[" Pattern_List "]" ;
rules Type ::= "(" Signature ")" | "(" Type "," [Type] ")" | "[" Type "]" | TypeToken ;
rules Literal ::= IntLiteral | FloatLiteral | CharLiteral | StringLiteral | BooleanLiteral ;
rules Struct_Instance ::= "[" Expr_List "]" | "(" Expr "," [Expr] ")" ;
rules Expr ::= Expr "||" Expr1 ;
rules Expr1 ::= Expr1 "&&" Expr2 ;
rules Expr2 ::= Expr2 EqNEq Expr3 ;
rules Expr3 ::= Expr3 LeGr Expr4 ;
rules Expr4 ::= Expr4 AddSub Expr5 ;
rules Expr5 ::= Expr5 MulDivRem Expr6 ;
rules Expr6 ::= Expr7 ":" Expr6 ;
rules Expr7 ::= Id | Struct_Instance | Expr "(" Expr_List ")" | "!" Expr | "-" Expr  | Literal ;

coercions Expr 7 ;

rules Pattern_List ::= Pattern_ListNE | ;
rules Pattern_ListNE ::= Pattern "," Pattern_ListNE | Pattern ;
rules Expr_List ::= [Expr] | ;

separator nonempty Func "" ;
separator nonempty Case "" ;
separator nonempty Type "," ;
separator nonempty Expr "," ;
separator Pattern "" ;

token EqNEq {"=="} | {"!="} ;
token LeGr {"<="} | {">="} | '<' | '>' ;
token AddSub '-' | '+' ;
token MulDivRem '*' | '/' | '%' ;
token IntLiteral digit+ ;
token FloatLiteral digit+ '.' digit+ ;
token CharLiteral '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ;
token StringLiteral '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ;
token BooleanLiteral ( {"True"} | {"False"} ) ;
token TypeToken ( {"Int"} | {"Bool"} | {"Float"} | {"String"} | {"Char"} ) ;
token Id letter (letter | digit | '_' | '\'')* ;

